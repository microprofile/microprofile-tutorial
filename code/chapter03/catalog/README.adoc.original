==== Mockito-Based Unit Testing

For true unit testing of the resource layer, we use Mockito to isolate the component being tested:

[source,java]
----
@ExtendWith(MockitoExtension.class)
public class MockitoProductResourceTest {
    @Mock
    private ProductService productService;
    
    @InjectMocks
    private ProductResource productResource;
    
    @Test
    void testGetAllProducts() {
        // Setup mock behavior
        List<Product> mockProducts = Arrays.asList(
            new Product(1L, "iPhone", "Apple iPhone 15", 999.99),
            new Product(2L, "MacBook", "Apple MacBook Air", 1299.0)
        );
        when(productService.getAllProducts()).thenReturn(mockProducts);
        
        // Call the method to test
        Response response = productResource.getAllProducts();
        
        // Verify the response
        assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());
        List<Product> returnedProducts = (List<Product>) response.getEntity();
        assertEquals(2, returnedProducts.size());
        
        // Verify the service method was called
        verify(productService).getAllProducts();
    }
}
----

=== Benefits of Mockito Testing

Using Mockito for resource layer testing provides several advantages:

* **True Unit Testing**: Tests only the resource class, not its dependencies
* **Controlled Environment**: Mock services return precisely what you configure
* **Faster Execution**: No need to initialize the entire service layer
* **Independence**: Tests don't fail because of problems in the service layer
* **Verify Interactions**: Ensure methods on dependencies are called correctly
* **Test Edge Cases**: Easily simulate error conditions or unusual responses

==== Testing Dependencies

[source,xml]
----
<!-- Mockito for mocking in tests -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>5.3.1</version>
    <scope>test</scope>
</dependency>
----