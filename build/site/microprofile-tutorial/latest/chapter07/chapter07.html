<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: MicroProfile Tutorial</title>
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">MicroProfile Tutorial</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="microprofile-tutorial" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-explore is-active" data-panel="explore">
  <div class="context">
    <span class="title">MicroProfile Tutorial</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">MicroProfile Tutorial</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
<div class="edit-this-page"><a href="file:///workspaces/microprofile-tutorial/./modules/ROOT/pages/chapter07/chapter07.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect1">
<h2 id="_chapter_7_microprofile_metrics"><a class="anchor" href="#_chapter_7_microprofile_metrics"></a>Chapter 7: MicroProfile Metrics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h3>
<div class="paragraph">
<p>This chapter provides a comprehensive and detailed overview of MicroProfile Metrics, a widely used specification for monitoring microservices. You will gain an understanding of the various types of metrics and how you can use them to monitor microservices effectively. Additionally, this chapter covers the standard metrics provided by MicroProfile and how you can leverage them to monitor various aspects of microservices.</p>
</div>
<div class="paragraph">
<p>Furthermore, this chapter discusses the process of instrumenting microservices, which involves adding code to the application to collect metrics. You will learn how to expose endpoints to access metric data and interpret the data generated by these metrics.</p>
</div>
<div class="paragraph">
<p>This chapter also highlights the importance of integrating monitoring solutions with MicroProfile Metrics. You will learn how to incorporate monitoring solutions and choose the right monitoring solution for your needs.</p>
</div>
<div class="paragraph">
<p>By the end of this chapter, you will have a deep understanding of MicroProfile Metrics and the various techniques for monitoring microservices. This chapter will equip you with the knowledge and skills to effectively monitor your microservices and ensure they perform optimally.</p>
</div>
</div>
<div class="sect2">
<h3 id="_topics_to_be_covered"><a class="anchor" href="#_topics_to_be_covered"></a>Topics to be covered:</h3>
<div class="ulist">
<ul>
<li>
<p>Introduction to MicroProfile Metrics</p>
</li>
<li>
<p>Need for Metrics in Microservices</p>
</li>
<li>
<p>Types of Metrics</p>
</li>
<li>
<p>MicroProfile Metrics Dependency</p>
</li>
<li>
<p>Metrics Annotations</p>
</li>
<li>
<p>Categories of Metrics</p>
</li>
<li>
<p>Metric Registry</p>
</li>
<li>
<p>Instrumenting Microservices with Metrics</p>
</li>
<li>
<p>Creating Custom Metrics</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_introduction_to_microprofile_metrics"><a class="anchor" href="#_introduction_to_microprofile_metrics"></a>Introduction to MicroProfile Metrics</h3>
<div class="paragraph">
<p>It is essential to monitor your microservices to ensure smooth operations. You can monitor a microservice using two different techniques: Metrics and health checking. Health checks provide information on the health status of a service, such as whether it is up and running, while Metrics offer more detailed information on its performance, such as response times, throughput, and error rates. In the previous chapter, we discussed health checks and their importance. This chapter will cover the MicroProfile Metrics specification, which provides a standardized way of collecting and exposing performance data for Java microservices.</p>
</div>
<div class="paragraph">
<p><strong>MicroProfile Metrics</strong> is a specification for developers who want to measure their applications' performance more thoroughly. It provides a set of annotations and APIs to track various metrics related to the application&#8217;s health and performance. For instance, developers can use these APIs to track metrics such as the number of requests processed, the response time of each request, and the size of the response sent back to the client.</p>
</div>
<div class="paragraph">
<p>This specification defines a standardized format for exposing metrics, which other tools and frameworks can easily collect and track. By using this specification, developers can monitor the performance of their applications in real time and identify any issues that may impact the user experience.</p>
</div>
<div class="paragraph">
<p>Moreover, this specification defines a set of standard metrics that we can expose in Prometheus. With the help of this tool, developers can optimize their applications for better performance, ensuring that they meet the requirements of their consumers while delivering a seamless experience.</p>
</div>
<div class="paragraph">
<p><strong>Prometheus</strong> is a powerful tool designed to monitor and collect metrics from your services. It provides a highly efficient time-series database system that securely stores your data for long-term analysis. With Prometheus, you can easily visualize and gain insights into your system&#8217;s performance, allowing you to make informed decisions and optimize your services for better efficiency and reliability.</p>
</div>
</div>
<div class="sect2">
<h3 id="_need_for_metrics_in_microservices"><a class="anchor" href="#_need_for_metrics_in_microservices"></a>Need for Metrics in Microservices</h3>
<div class="paragraph">
<p>Metrics, enables developers and operators to monitor and measure the behavior of microservices at runtime. This observability is crucial for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Performance Tuning</strong>: Identifying bottlenecks and optimizing resource utilization to ensure services are running efficiently.</p>
</li>
<li>
<p><strong>Scalability</strong>: Making informed decisions on when to scale services up or down based on real-time data on load and performance.</p>
</li>
<li>
<p><strong>Troubleshooting</strong>: Quickly pinpointing issues by analyzing trends in performance metrics, leading to reduced downtime.</p>
</li>
<li>
<p><strong>Service Health Monitoring</strong>: Complementing the MicroProfile Health checks by providing deeper insights into the internal state of a service, beyond simple up/down statuses.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_types_of_metrics"><a class="anchor" href="#_types_of_metrics"></a>Types of Metrics</h3>
<div class="paragraph">
<p>MicroProfile Metrics offers a range of customizable metrics that can be used to measure and monitor microservices' performance. It allows developing microservices that are observable, manageable, and which provide insights into their behavior.</p>
</div>
<div class="paragraph">
<p>The MicroProfile Metrics specification includes four different types of metrics that serve specific monitoring purposes: Counter, Gauge, Histogram, and Timer. Each of these types offers unique insights into different aspects of application behavior and performance. Below is the breakdown of available metric types:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Counter</strong>: It is a simple metric type that represents a single numerical value that can only increase over time. This metric is typically used to count occurrences of certain events, such as the number of requests processed, items created, or tasks completed. Monitoring tools like Prometheus are commonly used to analyze changes in the Counter&#8217;s value over specific intervals. These tools can track the differences in the Counter&#8217;s value across time periods, providing insights into the rate of occurrences and trends.</p>
</li>
<li>
<p><strong>Gauge</strong>: It is a metric type that measures an instantaneous value of something , which can arbitrarily go up or down. It’s used to capture the value of a metric at a particular point in time like the size of a queue, memory usage, or current number of active user sessions. Gauges are typically used for values that change over time, providing a current "gauge" of the system&#8217;s state.</p>
</li>
<li>
<p><strong>Histograms</strong>: They provide a distribution of values for a given metric, which are useful for identifying performance outliers. It measures the frequency of values in different ranges (or "buckets") and is useful for tracking the distribution of values, such as response times or data sizes. Histograms can give insights into the average, percentiles, and trends of the measured data over time.</p>
</li>
<li>
<p><strong>Timer</strong>: It is a specialized metric type that aggregates timing durations and provides data such as the count, total time, mean, and maximum duration. It can also report the duration distribution. Timers are invaluable for tracking the duration of certain activities or operations within your application, such as processing time or method execution time.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note: Counters, Histograms, and Timers, which are updated synchronously when annotations or API calls are made to update them, Gauges are registered as callbacks. These callbacks are invoked to retrieve their value at the moment the list of metrics is requested, typically by a monitoring tool calling the /metrics endpoint. This allows Gauges to provide a real-time snapshot of dynamic values as they fluctuate.</p>
</div>
<div class="paragraph">
<p>By leveraging these metrics, developers and operators can gain a deeper understanding of how their microservices are performing. They can use this information to identify areas where improvements can be made and optimize their microservices' performance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_microprofile_metrics_dependency"><a class="anchor" href="#_microprofile_metrics_dependency"></a>MicroProfile Metrics Dependency</h3>
<div class="paragraph">
<p>If you&#8217;re using Maven, add the following dependency to your pom.xml file located in the root folder of your project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.microprofile.metrics&lt;/groupId&gt;
  &lt;artifactId&gt;microprofile-metrics-api&lt;/artifactId&gt;
  &lt;version&gt;5.1.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For Gradle, add the corresponding dependency to your build.gradle file located within the root folder of your project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">dependencies {
    providedCompile 'org.eclipse.microprofile.metrics:microprofile-metrics-api:5.1.1'
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_metrics_annotations"><a class="anchor" href="#_metrics_annotations"></a>Metrics Annotations</h3>
<div class="paragraph">
<p>MicroProfile Metrics defines a set of annotations to be used for exposing metrics. These annotations can be used on classes, methods, or fields. Table 7-1 shows the list of Metrics Annotation along with their descriptions.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 71.4286%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Annotation</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Timed</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Times how long a method takes to execute and exposes this information as a metric.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Counted</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tracks how many times a method is invoked and exposes this information as a metric.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Gauge</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables you to expose a custom metric that can be any value. It is useful for exposing application-specific metrics.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Besides annotations, MicroProfile Metrics also defines a set of programmatic APIs for working with metrics. These APIs can be used to register custom metrics or access existing metrics.</p>
</div>
</div>
<div class="sect2">
<h3 id="_categories_of_metrics"><a class="anchor" href="#_categories_of_metrics"></a>Categories of Metrics</h3>
<div class="paragraph">
<p>In MicroProfile Metrics, metrics are organized into three distinct scopes: Base, Vendor, and Application. This categorization is designed to clearly separate metrics by their origin and relevance, making it easier for developers and operators to monitor and manage the performance of their microservices. Each scope serves a specific purpose and contains a different set of metrics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Base Metrics</strong> are common to all applications, such as the number of CPUs or the amount of free memory. These metrics provide essential information about the underlying Java Virtual Machine (JVM) and the core libraries that are common across all MicroProfile applications. Base metrics typically include JVM-specific metrics such as memory usage, CPU load, thread counts, and garbage collection statistics. The intention behind base metrics is to offer a consistent set of low-level metrics that are universally applicable and useful for monitoring the health and performance of the JVM itself, which is the foundation upon which all MicroProfile applications run.
Base metrics are exposed under the path <code>/metrics?scope=base</code>.</p>
</li>
<li>
<p><strong>Application Metrics</strong> are specific to an application, they are defined by the developers of the MicroProfile applications themselves. These are custom metrics that are specific to the business logic or operational aspects of the application. Developers use annotations or programmatic APIs to create and register these metrics, tailoring them to monitor the performance and behavior of their application&#8217;s unique functionalities. Application metrics enable developers to gain insights into the runtime characteristics of their application, such as the number of transactions processed, response times for specific endpoints, or the rate of specific business events.
Application metrics are exposed under the path <code>/metrics?scope=application</code>.</p>
</li>
<li>
<p><strong>Vendor Metrics</strong> are specific to a particular vendor or technology. These metrics provide insights into the performance and behavior of the runtime&#8217;s internal components and extensions. Since different MicroProfile implementations may offer additional features or optimize certain areas differently, vendor metrics can vary widely between runtimes. They allow runtime vendors to expose unique metrics that are relevant to their implementation, offering users the ability to monitor vendor-specific aspects of their applications.
Application metrics are exposed under the path <code>/metrics?scope=vendor</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Besides the standard scopes above, MicroProfile Metrics also supports custom scopes. You can use custom scopes to group sets of metrics that you frequently expect to view together.</p>
</div>
<div class="paragraph">
<p>Note: In version 5.x, base metrics have become optional. This allows for flexibility in environments where these metrics may not be necessary or where they can be sourced from alternative monitoring tools.</p>
</div>
</div>
<div class="sect2">
<h3 id="_metric_registry"><a class="anchor" href="#_metric_registry"></a>Metric Registry</h3>
<div class="paragraph">
<p>The <strong>MetricRegistry</strong> component acts as a container for storing and managing metrics within an application. It provides a structured way to collect, organize, and access various types of metrics (e.g., counters, gauges, histograms, and timers) for monitoring the behavior and performance of applications. It offers a centralized repository where metrics can be created and retrieved. This allows applications to consistently monitor critical operational and performance statistics.</p>
</div>
<div class="sect3">
<h4 id="_types_of_metric_registries"><a class="anchor" href="#_types_of_metric_registries"></a>Types of Metric Registries</h4>
<div class="paragraph">
<p>MicroProfile Metrics creates metric registries for each scope:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Application Scope (<code>MetricRegistry.Type.APPLICATION</code>): Contains custom metrics that are specific to the application. These are typically the metrics that developers explicitly create and register to monitor application-specific behaviors.</p>
</li>
<li>
<p>Base Scope (<code>MetricRegistry.Type.BASE</code>): Contains metrics that are fundamental and common across all MicroProfile applications. These metrics provide basic information about the underlying JVM and application server.</p>
</li>
<li>
<p>Vendor Scope (<code>MetricRegistry.Type.VENDOR</code>): Contains metrics that are specific to the implementation of the MicroProfile platform being used. These metrics offer insights into vendor-specific features and optimizations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A metric registry is created as per the above scopes to enable the organization of metrics based on their origin and relevance.</p>
</div>
</div>
<div class="sect3">
<h4 id="_instrumenting_microservices_with_microprofile_metrics"><a class="anchor" href="#_instrumenting_microservices_with_microprofile_metrics"></a>Instrumenting Microservices with MicroProfile Metrics</h4>
<div class="paragraph">
<p>Instrumenting microservices with MicroProfile Metrics enables developers to gain detailed insights into their application&#8217;s operational health and performance. This level of observability is essential for maintaining scalable and resilient microservice architectures in dynamic environments.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tracking_response_time_using_timed"><a class="anchor" href="#_tracking_response_time_using_timed"></a>Tracking response time using <code>@Timed</code></h4>
<div class="paragraph">
<p>MicroProfile Metrics also allows you to track a method&#8217;s response time as a timed metric. The code example below shows how to use the @Timed annotation to track the response time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">import org.eclipse.microprofile.metrics.annotation.Timed;
// …

public class ProductResource {

    // …
    // Expose the response time as a timer metric
    @Timed(name = "productLookupTime",
            tags = {"method=getProduct"},
            absolute = true,
            description = "Time spent looking up products")
    public Product getProduct(@PathParam("id") Long productId) {
        return productService.getProduct(productId);
    }

    // …</code></pre>
</div>
</div>
<div class="paragraph">
<p>It will expose a metric called <code>productLookupTime</code>, which will track the amount of time spent in the <code>getProduct()</code> method in seconds.
You can visit the following URL <code>https://localhost:&lt;port&gt;/metrics?scope=application</code> (Replace <code>&lt;port&gt;</code> with the actual port where the server is running) to see the response time of this method as below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">…
# HELP productLookupTime_seconds_max Time spent looking up products
# TYPE productLookupTime_seconds_max gauge
productLookupTime_seconds_max{method="getProduct",mp_scope="application",} 0.002270643
…</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tracking_number_of_invocations_using_counted"><a class="anchor" href="#_tracking_number_of_invocations_using_counted"></a>Tracking number of invocations using <code>@Counted</code></h4>
<div class="paragraph">
<p>MicroProfile Metrics also allows you to track the number of invocations of a method as a counter metric. The code example below shows how to use the <code>@Counted</code> annotation to track the invocation count.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.eclipse.microprofile.metrics.Metrics;

public class ProductResource {

    // Expose the invocation count as a counter metric
    @Counted(name = "productAccessCount",
        absolute = true,
        description = "Number of times the list of products is requested")
    public Response getProducts() {
       // Method implementation
       // ....
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, the <code>@Counted</code> annotation tells MicroProfile Metrics to track the number of invocations of the <code>getProducts()</code> method and expose this metric as a counter. The name, and description of the metric can also be specified.
You can visit the following URL <code>https://localhost:&lt;port&gt;/metrics?scope=application</code> (Replace <code>&lt;port&gt;</code> with the actual port where the server is running) to see the number of times this method is called as below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">…
# HELP productAccessCount_total Number of times the list of products is requested
# TYPE productAccessCount_total counter
productAccessCount_total{mp_scope="application",} 3.0
…</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_custom_metric"><a class="anchor" href="#_creating_a_custom_metric"></a>Creating a Custom Metric</h3>
<div class="paragraph">
<p>Creating a custom metric to track the number of products in a catalog involves using the MicroProfile Metrics API. This custom metric can be implemented as a gauge, which measures an instantaneous value (in this case, the current number of products in the catalog).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.eclipse.microprofile.metrics.annotation.Gauge;
…

@Path("/products")
@ApplicationScoped
public class ProductResource {
  // …

  @GET
  @Path("/count")
  @Produces(MediaType.APPLICATION_JSON)
  @Gauge(name = "productCatalogSize",
    unit = "none",
  description = "Current number of products in the catalog")
  public long getProductCount() {
     return productCatalogSize;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The gauge metric <code>productCatalogSize</code> can be accessed through the following endpoint:</p>
</div>
<div class="paragraph">
<p><code>/metrics?name=io_microprofile_tutorial_store_product_resource_ProductResource_productCatalogSize</code></p>
</div>
<div class="paragraph">
<p>This custom metric implementation provides a real-time insight into the size of your product catalog, which can be invaluable for monitoring the scale of your service&#8217;s data and understanding its behavior over time.</p>
</div>
<div class="paragraph">
<p>Vendors may, by their own implementation, support <code>/metrics?name=&lt;name&gt;</code> to directly retrieve that metric from all scopes. However, the specification itself only illustrates <code>/metrics?scope=&lt;scope&gt;&amp;name=&lt;name&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_summary"><a class="anchor" href="#_summary"></a>Summary</h3>
<div class="paragraph">
<p>This Chapter delved into the intricacies of MicroProfile Metrics, illuminating its role as a pivotal specification for efficiently monitoring microservices. Now you are equipped with a thorough understanding of diverse metric types and their application for monitoring microservice performance. This chapter highlighted the need for regular microservice monitoring via metrics and health checks, emphasizing metrics for detailed performance insights such as response times and throughput. Through practical examples, this chapter showcases how to instrument microservices with MicroProfile Metrics, leveraging standard metrics, and creating custom metrics to monitor microservices comprehensively.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
